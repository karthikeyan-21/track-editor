/**
 * BSD Zero Clause License
 *
 * Copyright (c) 2012 Karthikeyan Natarajan (karthikeyan21@gmail.com)
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
package com.editor.track;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Properties;
import java.util.Vector;

import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.ImageLoader;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.widgets.Display;

import tiled.core.MapLayer;
import tiled.core.Tile;
import tiled.core.TileLayer;
import tiled.core.TileSet;
import tiled.io.xml.XMLMapTransformer;
import tiled.io.xml.XMLMapWriter;

import com.editor.track.TileMatrix.Grid;

public class TileManifest extends Properties {
	
	public static final String TILES 			= "Tile-Info";
	public static final String LAYER_ONE 		= "Layer-One";
	public static final String LAYER_TWO 		= "Layer-Two";
	public static final String LAYER_THREE 		= "Layer-Three";
	public static final String GRID_DIMENSION 	= "Grid-Dimension";
	public static final String START_LOCATION   = "Start-Location";
	public static final String END_LOCATION     = "End-Location";
	public static final String PRIMITIVES 		= "primitives";
	public static final String CURVE 			= "curve";
	public static final String LINE 			= "line";
	public static final String BACKGROUND_COLOR = "background-color";

	private static final long serialVersionUID = 1L;
	
	private String fileLocation;
	
	public TileManifest() {
	}
	
	public TileManifest(String fileLocation) {
		if(fileLocation == null || fileLocation.length() == 0) {
			throw new IllegalArgumentException("Invalid file location");
		}
		if(!fileLocation.endsWith(".tmf")) {
			throw new IllegalArgumentException("Unsupported file extension");
		}
		if(!new File(fileLocation).exists()) {
			throw new IllegalArgumentException("File does not exist!");
		}
		try {
			setFileLocation(fileLocation);
			load(new FileReader(fileLocation));
			getGrids();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
	
	public void setFileLocation(String fileLocation) {
		this.fileLocation = fileLocation;
	}
	
	public String getFileLocation() {
		return fileLocation;
	}
	
	public void save() {
		if(getFileLocation() != null) {
			try {
				store(new FileWriter(fileLocation), "Generated by Rally Editor v2");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void setTrackData(Map<String,List<Point>> pDatas) {
		for(String key : pDatas.keySet()) {
			List<Point> pData = pDatas.get(key);
			StringBuilder buffer = new StringBuilder();
			for(int i = 0;i < pData.size();i++){
				Point data = pData.get(i);
				if(i > 0) {
					buffer.append(",");
				}
				buffer.append(data.x).append(",").append(data.y);
			}
			setProperty(PRIMITIVES+"."+key, buffer.toString());
		}
	}
	
	public Map<String,List<Point>> getTrackData() {
		Map<String,List<Point>> result = new HashMap<String,List<Point>>();
		for(int index = 1;;index++) {
			String property = getProperty(PRIMITIVES+"."+index);
			if(property != null && property.trim().length() > 0) {
				String[] tokens = property.split(",");
				List<Point> points = new ArrayList<Point>();
				result.put(String.valueOf(index), points);
				for(int i = 0 ; i < tokens.length ; i += 2) {
					points.add(new Point(Integer.parseInt(tokens[i]),Math.abs(Integer.parseInt(tokens[i+1]))));
				}
			} else {
				break;
			}
		}
		return result;
	}
	
	public void setBackgroundColor(RGB rgb) {
		setProperty(BACKGROUND_COLOR, rgb.red+","+rgb.green+","+rgb.blue);
	}
	
	public RGB getBackgroundColor() {
		String property = getProperty(BACKGROUND_COLOR);
		String[] tokens = null;
		if(property != null && (tokens = property.split(",")).length == 3) {
			return new RGB(Integer.parseInt(tokens[0].trim()),Integer.parseInt(tokens[1].trim()),Integer.parseInt(tokens[2].trim()));
		}
		return null;
	}
	
	public void setGridDimension(int rows,int cols) {
		StringBuilder sb = new StringBuilder();
		sb.append(Integer.toString(rows)).append(",").append(Integer.toString(cols));
		setProperty(GRID_DIMENSION, sb.toString());
	}

	public int[] getGridDimension() {
		int[] dimension = new int[2];
		String property = getProperty(GRID_DIMENSION);
		if(property != null && property.split(",").length == 2) {
			String[] split = property.split(",");
			dimension[0] = Integer.parseInt(split[0]);
			dimension[1] = Integer.parseInt(split[1]);
		}
		return dimension;
	}
	
	public void setGrids(TileMatrix matrix) {
		
		XMLMapWriter mapWriter = new XMLMapWriter();
		
		int[] gridDimensions = getGridDimension();
		tiled.core.Map layeredMap = new tiled.core.Map(gridDimensions[1],gridDimensions[0]);
		layeredMap.setTileHeight(CanvasView.GRID_SIZE);
		layeredMap.setTileWidth(CanvasView.GRID_SIZE);
		
		Map<Integer,tiled.core.Tile> tileMap = new HashMap<Integer,tiled.core.Tile>();
		Map<Integer,Image> imageMap = new HashMap<Integer,Image>();
		
		TileLayer layer1 = (TileLayer) layeredMap.addLayer();
		TileLayer layer2 = (TileLayer) layeredMap.addLayer();
		TileLayer layer3 = (TileLayer) layeredMap.addLayer();

		TileSet tileSet = new TileSet();
		tileSet.setFirstGid(1);
		tileSet.setName("default");
		layeredMap.addTileset(tileSet);
		
		for(Grid grid : matrix.getGrids()) {
			TileInfo tileInfo = grid.getTileInfo(0);
			if(tileInfo != null) {
				setTile(tileSet, layeredMap, tileMap, layer1, grid, tileInfo, imageMap);
			}
			tileInfo = grid.getTileInfo(1);
			if(tileInfo != null) {
				setTile(tileSet, layeredMap, tileMap, layer2, grid, tileInfo, imageMap);
			}
			tileInfo = grid.getTileInfo(2);
			if(tileInfo != null) {
				setTile(tileSet, layeredMap, tileMap, layer3, grid, tileInfo, imageMap);
			}
		}
		tileSet.setTilesetImageFilename(fileLocation+".png");
		if(tileMap.size() == 0) {
			return;
		}
		int width = Math.min(50, tileMap.size());
		int height = tileMap.size() / width;
		Image newImage = new Image(Display.getDefault(),CanvasView.GRID_SIZE * width,CanvasView.GRID_SIZE * height);
		GC gc = new GC(newImage);
		int srcx = 0;
		int srcy = 0;
		final int imgWidth = width * CanvasView.GRID_SIZE;
		for(int i = 0;i < imageMap.size() ; i++) {
			Image image = imageMap.get(i);
			Rectangle bounds = image.getBounds();
			ImageData rotate = rotate(image.getImageData(), SWT.DOWN);
			Image _image = new Image(Display.getDefault(),rotate);
			gc.drawImage(_image, 0, 0,bounds.width,bounds.height,srcx,srcy,CanvasView.GRID_SIZE,CanvasView.GRID_SIZE);
			_image.dispose();
			srcx += CanvasView.GRID_SIZE;
			if(srcx > imgWidth) {
				srcx = 0;
				srcy += CanvasView.GRID_SIZE;
			}
		}
		gc.dispose();
		try {
			ImageLoader loader = new ImageLoader();
		    ImageData imageData = newImage.getImageData();
//			imageData.transparentPixel = newImage.getImageData().palette.getPixel(new RGB(255,255,255));
			loader.data = new ImageData[] { imageData };
		    loader.save(fileLocation+".png", SWT.IMAGE_PNG);
			mapWriter.writeMap(layeredMap, fileLocation+".tmx");
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if(mapWriter != null) {

			}
		}
	}

	private void setTile(TileSet tileSet,tiled.core.Map layeredMap, Map<Integer, tiled.core.Tile> tileMap,TileLayer layer, Grid grid, TileInfo tileInfo,Map<Integer,Image> imageMap) {
		tiled.core.Tile tmp = tileMap.get(tileInfo.getId());
		if(tmp == null) {
			int id = tileMap.size();
			tmp = new tiled.core.Tile() {
				@Override
				public int getHeight() {
					return CanvasView.GRID_SIZE;
				}
				@Override
				public int getWidth() {
					return CanvasView.GRID_SIZE;
				}
			};
			tmp.setId(id);
			imageMap.put(id, tileInfo.getImage());
			tmp.setImage(id);
//			tmp.setImage(ImageRegistry.convertToAWT(tileInfo.getImage().getImageData()));
			tileSet.addTile(tmp);
			tileMap.put(tileInfo.getId(), tmp);
		}
		layer.setTileAt(grid.getX(), layeredMap.getHeight() - grid.getY(), tmp);
//		layer.setTileAt(grid.getX(), grid.getY(), tmp);
	}

	private Map<Integer,TileInfo> tileInfo;
	
	public void setTileInfo(Map<Integer,TileInfo> tileInfo) {
		this.tileInfo = tileInfo;
	}
	
	public Map<Integer,TileInfo> getTileInfo() {
		return tileInfo;
	}
	
	public TileMatrix getGrids() {
		int[] dim = getGridDimension();
		TileMatrix tileMatrix = new TileMatrix(dim[0],dim[1]);
		setTileInfo(new HashMap<Integer,TileInfo>());
		if(!new File(fileLocation+".tmx").exists()) {
			return tileMatrix;
		}
		XMLMapTransformer reader = new XMLMapTransformer();
		try {
			tiled.core.Map map = reader.readMap(fileLocation+".tmx");
			Map<Integer, Image> imageMap = loadImageMap(fileLocation+".png");
			Vector<TileSet> tilesets = map.getTilesets();
			for(TileSet tileSet : tilesets) {
				for(int i = 0;i < tileSet.size();i++) {
					Tile tile = tileSet.getTile(i);
					TileInfo tInfo = new TileInfo(tile.getId(),imageMap.get(tile.getId()));
					getTileInfo().put(new Integer(tile.getId()), tInfo);
				}
			}
			ListIterator<MapLayer> layers = map.getLayers();
			TileLayer layer1 = (TileLayer) layers.next();
			TileLayer layer2 = (TileLayer) layers.next();
			TileLayer layer3 = (TileLayer) layers.next();
			Map<Integer, TileInfo> tileInfo = getTileInfo();
			int height = dim[0],width = dim[1];
			for(int i = 0;i < height; i++) {
				for(int j = 0; j<width;j++) {
					Tile tileAt = layer1.getTileAt(i, j); 
					TileInfo tileInfo2 = null;
					if(tileAt != null) {
						tileInfo2 = tileInfo.get(tileAt.getId());
						tileMatrix.add(i, height - j, 0, tileInfo2);
					}
					tileAt = layer2.getTileAt(i, j);
					if(tileAt != null) {
						tileInfo2 = tileInfo.get(tileAt.getId());
						tileMatrix.add(i, height - j, 1, tileInfo2);
					}
					tileAt = layer3.getTileAt(i, j);
					if(tileAt != null) {
						tileInfo2 = tileInfo.get(tileAt.getId());
						tileMatrix.add(i, height - j, 2, tileInfo2);
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return tileMatrix;
	}
	

	private Map<Integer, Image> loadImageMap(String file) {
		Map<Integer,Image> imageMap = new HashMap<Integer,Image>();
		int srcx = 0;
		int srcy = 0;
		ImageLoader loader = new ImageLoader();
		ImageData[] load = loader.load(file);
		Image image = new Image(Display.getDefault(),load[0]);
		Rectangle imageBounds = image.getBounds();
		int id = 0;
		while(true) {
			Image newImage = new Image(Display.getDefault(),CanvasView.GRID_SIZE,CanvasView.GRID_SIZE);
			GC gc = new GC(newImage);
			gc.drawImage(image, srcx, srcy, CanvasView.GRID_SIZE, CanvasView.GRID_SIZE, 0, 0, CanvasView.GRID_SIZE, CanvasView.GRID_SIZE);
			ImageData rotate = rotate(newImage.getImageData(), SWT.DOWN);
			gc.dispose();
			imageMap.put(id++, new Image(Display.getDefault(),rotate));
			newImage.dispose();
			srcx += CanvasView.GRID_SIZE;
			if(srcx >= imageBounds.width) {
				srcx = 0;
				srcy += CanvasView.GRID_SIZE;
			}
			if(srcy >= imageBounds.height) {
				break;
			}
		}
		return imageMap;
	}

	static ImageData rotate(ImageData srcData, int direction) {
		int bytesPerPixel = srcData.bytesPerLine / srcData.width;
		int destBytesPerLine = (direction == SWT.DOWN)? srcData.width * bytesPerPixel : srcData.height * bytesPerPixel;
		byte[] newData = new byte[(direction == SWT.DOWN)? srcData.height * destBytesPerLine : srcData.width * destBytesPerLine];
		int width = 0, height = 0;
		for (int srcY = 0; srcY < srcData.height; srcY++) {
			for (int srcX = 0; srcX < srcData.width; srcX++) {
				int destX = 0, destY = 0, destIndex = 0, srcIndex = 0;
				switch (direction){
					case SWT.LEFT: // left 90 degrees
						destX = srcY;
						destY = srcData.width - srcX - 1;
						width = srcData.height;
						height = srcData.width; 
						break;
					case SWT.RIGHT: // right 90 degrees
						destX = srcData.height - srcY - 1;
						destY = srcX;
						width = srcData.height;
						height = srcData.width; 
						break;
					case SWT.DOWN: // 180 degrees
						destX = srcData.width - srcX - 1;
						destY = srcData.height - srcY - 1;
						width = srcData.width;
						height = srcData.height; 
						break;
				}
				destIndex = (destY * destBytesPerLine) + (destX * bytesPerPixel);
				srcIndex = (srcY * srcData.bytesPerLine) + (srcX * bytesPerPixel);
				System.arraycopy(srcData.data, srcIndex, newData, destIndex, bytesPerPixel);
			}
		}
		// destBytesPerLine is used as scanlinePad to ensure that no padding is required
		return new ImageData(width, height, srcData.depth, srcData.palette, srcData.scanlinePad, newData);
	}
	public static void main(String...strings) {
		TileManifest tileManifest = new TileManifest();
		tileManifest.setGridDimension(20,20);
		try {
			tileManifest.store(new FileWriter("d:/sample.tmf"), "this is comments");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
}