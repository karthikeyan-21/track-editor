package com.editor.track;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

import org.eclipse.swt.graphics.Point;

import com.editor.track.LineSegment.OpaqueSide;
import com.editor.track.TileMatrix.Grid;


public class TileManifest extends Properties {
	
	public static final String TILES 			= "Tile-Info";
	public static final String LAYER_ONE 		= "Layer-One";
	public static final String LAYER_TWO 		= "Layer-Two";
	public static final String LAYER_THREE 		= "Layer-Three";
	public static final String GRID_DIMENSION 	= "Grid-Dimension";
	public static final String START_LOCATION   = "Start-Location";
	public static final String END_LOCATION     = "End-Location";
	public static final String PRIMITIVES = "primitives";
	public static final String CURVE = "curve";
	public static final String LINE = "line";

	private static final long serialVersionUID = 1L;
	
	public TileManifest() {
	}
	
	public TileManifest(String fileLocation) {
		if(fileLocation == null || fileLocation.length() == 0) {
			throw new IllegalArgumentException("Invalid file location");
		}
		if(!fileLocation.endsWith(".tmf")) {
			throw new IllegalArgumentException("Unsupported file extension");
		}
		if(!new File(fileLocation).exists()) {
			throw new IllegalArgumentException("File does not exist!");
		}
		try {
			load(new FileReader(fileLocation));
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
	
	public void setTileInfo(Map<Integer,TileInfo> tiles) {
		StringBuilder sb = new StringBuilder();
		for(Entry<Integer,TileInfo> entry : tiles.entrySet()) {
			if(sb.length() > 0) {
				sb.append(",");
				sb.append("\n");
			}
			TileInfo tile = entry.getValue();
			sb.append(tile.getId()).append(",");
			sb.append(tile.getImageLocation());
			String className = tile.getClassName();
			if(className != null && className.length() > 0) {
				sb.append(",");
				sb.append(className);
			}
			LineSegment collisionRay = tile.getCollisionRay();
			if(collisionRay != null) {
				Point source = collisionRay.getSource();
				Point dest = collisionRay.getDestination();
				OpaqueSide side = collisionRay.getSide();
				sb.append(",").append(source.x).append("-");
				sb.append(source.y).append("-").append(side.name());
				sb.append("-").append(dest.x).append("-").append(dest.y);
			}
		}
		setProperty(TILES, sb.toString());
	}
	
	public Map<Integer,TileInfo> getTileInfo() {
		Map<Integer,TileInfo> tiles = new HashMap<Integer,TileInfo>();
		String property = getProperty(TILES);
		if(property != null) {
			String line = null;
			LineNumberReader reader = new LineNumberReader(new StringReader(property));
			String baseLocation = new File("").getAbsolutePath().replaceAll("\\\\", "/");
			try {
				while((line = reader.readLine())!=null) {
					String[] tokens = line.split(",");
					if(tokens != null && tokens.length >= 2) {
						String location = new File(tokens[1]).exists()?tokens[1]:baseLocation+tokens[1];
						TileInfo info = new TileInfo(tokens[0],location);
						int i = 0;
						if(tokens.length == 3 && !tokens[2].contains("-") ) {
							info.setClassName(tokens[2]);
							i = 3;
						} else {
							i = 2;
						}
						if(tokens.length > i) {
							String[] collisionTokens = tokens[i].split("-");
							Point source = new Point(Integer.parseInt(collisionTokens[0]),Integer.parseInt(collisionTokens[1]));
							OpaqueSide side = OpaqueSide.valueOf(collisionTokens[2]); 
							Point dest = new Point(Integer.parseInt(collisionTokens[3]),Integer.parseInt(collisionTokens[4]));
							info.setCollisionRay(new LineSegment(source,dest,side));
						}
						tiles.put(Integer.parseInt(tokens[0]), info);
					}
				}
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				try {
					reader.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		return tiles;
	}
	
	public void setTrackData(Map<String,List<Point>> pDatas) {
		StringBuilder buffer = new StringBuilder();
		int index = 1;
		for(List<Point> pData : pDatas.values()) {
			for(int i = 0;i < pData.size();i++){
				Point data = pData.get(i);
				if(i > 0) {
					buffer.append(",");
				}
				buffer.append(data.x).append(",").append(data.y);
			}
			setProperty(PRIMITIVES+"."+index, buffer.toString());
		}
	}
	
	public Map<String,List<Point>> getTrackData() {
		Map<String,List<Point>> result = new HashMap<String,List<Point>>();
		for(int index = 1;;index++) {
			String property = getProperty(PRIMITIVES+"."+index);
			if(property != null) {
				String[] tokens = property.split(",");
				List<Point> points = new ArrayList<Point>();
				result.put(String.valueOf(index), points);
				for(int i = 0 ; i < tokens.length ; i += 2) {
					points.add(new Point(Integer.parseInt(tokens[i]),Integer.parseInt(tokens[i+1])));
				}
			} else {
				break;
			}
		}
		return result;
	}
	
	public void setGridDimension(int rows,int cols) {
		StringBuilder sb = new StringBuilder();
		sb.append(Integer.toString(rows)).append(",").append(Integer.toString(cols));
		setProperty(GRID_DIMENSION, sb.toString());
	}

	public int[] getGridDimension() {
		int[] dimension = new int[2];
		String property = getProperty(GRID_DIMENSION);
		if(property != null && property.split(",").length == 2) {
			String[] split = property.split(",");
			dimension[0] = Integer.parseInt(split[0]);
			dimension[1] = Integer.parseInt(split[1]);
		}
		return dimension;
	}
	
	public void setGrids(TileMatrix matrix) {
		StringBuilder sb = new StringBuilder();
		StringBuilder sb1 = new StringBuilder();
		StringBuilder sb2 = new StringBuilder();
		for(Grid grid : matrix.getGrids()) {
			if(sb.length() != 0) {
				sb.append(",");
				sb1.append(",");
				sb2.append(",");
			}
			TileInfo tileInfo = grid.getTileInfo(0);
			sb.append((tileInfo != null) ? tileInfo.getId() : "0");
			tileInfo = grid.getTileInfo(1);
			sb1.append((tileInfo != null) ? tileInfo.getId() : "0");
			tileInfo = grid.getTileInfo(2);
			sb2.append((tileInfo != null) ? tileInfo.getId() : "0");
		}
		setProperty(LAYER_ONE, sb.toString());
		setProperty(LAYER_TWO, sb1.toString());
		setProperty(LAYER_THREE, sb2.toString());
	}

	public TileMatrix getGrids() {
		String layer1 = getProperty(LAYER_ONE);
		String layer2 = getProperty(LAYER_TWO);
		String layer3 = getProperty(LAYER_THREE);
		int[] dim = getGridDimension();
		TileMatrix tileMatrix = new TileMatrix(dim[0],dim[1]);
		Map<Integer, TileInfo> tileInfo = getTileInfo();
		fill(tileMatrix,dim[0],dim[1],0,tileInfo,layer1);
		fill(tileMatrix,dim[0],dim[1],1,tileInfo,layer2);
		fill(tileMatrix,dim[0],dim[1],2,tileInfo,layer3);
		return tileMatrix;
	}
	
	private void fill(TileMatrix tileMatrix,int rows,int cols,int zIndex,Map<Integer, TileInfo> tileInfo, String layer) {
		String[] tokens = layer.split(",");
		int index = 0;
		for(int i = 0;i < rows; i++) {
			for(int j = 0; j<cols;j++) {
				String id = "0";
				if(tokens.length < index) {
					id = tokens[index++];
				}
				TileInfo tileInfo2 = tileInfo.get(Integer.parseInt(id));
				tileMatrix.add(j, i, zIndex, tileInfo2);
			}
		}
	}

	public static void main(String...strings) {
		TileManifest tileManifest = new TileManifest();
		tileManifest.setGridDimension(20,20);
		try {
			tileManifest.store(new FileWriter("d:/sample.tmf"), "this is comments");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
}